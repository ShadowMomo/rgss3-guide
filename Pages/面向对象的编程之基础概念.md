# 面向对象的编程之基础概念 #
#### 基础概念 真的只有概念 又长又冗杂 ####
**方法**就是做一件事情所使用的方法

**对象**就是可以做事情的的主体

**类**就是一个以*能够处理的方法*对*对象*所进行的分类 

这还是有点以理解，这样你就懂了：
> *李华做物理实验*

*李华*是一个对象，*做*是一个方法，*物理实验*是方法的**参数**（至于参数，我们稍后再讲）

把一个事件用一句话说出来，一般名词是对象，动词是方法，宾语是参数
> 如果要*做物理实验*，应该让谁来？应该是*懂物理知识的人*

这里*懂物理知识的人*就是一个类
> *李华*是一个*红星中学高二一班的好学生*，而*红星中学高二一班的好学生*都是*懂物理知识的人*

这种情况，我们说：*李华*的类是*红星中学高二一班的好学生*

而*红星中学高二一班的好学生*的**父类**(也叫基类、超类)是*懂物理知识的人*

反过来说，类*懂物理知识的人*的**子类**(也叫派生类)**之一**是*红星中学高二一班的好学生*

为什么要说“之一”呢？

因为一个类只能有一个父类，而一个父类可以有多个子类<del>不要问我它妈是谁</del>

有一件显而易见的事：红星中学高二一班的好学生不止李华一个，所以说*李华*是*红星中学高二一班的好学生*的一个实际例子

你要红星中学高二一班的好学生？行啊！这里就有一个例子：李华

于是，我们说：对象*李华*是类*红星中学高二一班的好学生*的一个**实例**
#### 好 现在让我们回顾一下这些概念 ####
方法 对象 类 参数 实例 父类 子类

回顾完毕
#### 这些东西有什么意义 ####
理解这些东西，可以让脚本的逻辑结构更清晰——这是不言而喻的

更重要的是，这种模型可以让脚本编写更加简单

 ~~~最重要的是……ruby是一门面向对象的语言，RGSS3是建立在ruby上的，RGSS3的原装脚本是用这种思想写的 不用不行啊~~~

忽略上面那句，说点实际的：

方法的作用很简单明了，假设没有方法，而想要*扔肥皂*给@fux2 和@咕噜 我们得这样：
```从肥皂盒里拿出一块肥皂
瞄准@fux2 的脚下
抬手，把肥皂扔出去
从肥皂盒里拿出一块肥皂
瞄准@咕噜 的脚下
抬手，把肥皂扔出去
```

倘若我们以后还要再扔其他人，就必须再写一遍，如果有方法
```
# 目标是参数
定义方法 扔肥皂给(目标)
  从肥皂盒里拿出一块肥皂
  瞄准目标的脚下
  抬手，把肥皂扔出去
结束定义
```

我们就可以这样：

`扔肥皂给( @fux2 )`和`扔肥皂给( @咕噜 )`。

以后我们还可以`扔肥皂给( @好男人 )`。

至于类呢？

考虑这样一个方法：

**工作**

它应该是怎样的一个方法，会干什么？

…………

……………………

………………………………

对于不同的人（对象），同样的方法有不同的诠释

我们可以为每个人写一个方法：你是这样工作的 他是这样工作的 blablablabla...

但是我们会发现，总有一些人，他们工作的方法是一样的

把他们作为一类

（以`#`开头的是注释 不影响实际的效果）
```
定义类 清洁工
  定义方法 工作
    说 我不知道我要干什么
  结束定义
  定义方法 休息
    说 我在休息
  结束定义
结束定义
#-------
定义类 擦黑板的 父类是 清洁工
  定义方法 工作
    洗拖把
    前拖拖
    后拖拖
    里拖拖
    外拖拖
  结束定义
结束定义
#-------
定义类 扫地的 父类是 清洁工
  定义方法 工作
    洗抹布
    左擦擦
    右擦擦
    上擦擦
    下擦擦
  结束定义
结束定义
```

然后

```
李华的同学甲 是 一个扫地的 并且 李华的同学乙 是 一个擦黑板的
李华的同学甲工作 并且 李华的同学乙休息
```

好吧我受够了：

```
(classmateA = Sweeper.new) and (classmateB = Wiper.new)
classmateA.work and classmateB.rest
```

能看懂吧？

What? and不是这么用的？……我们后面再说。

话归正传，在这个例子中，我们看到了**继承**，继承指的是由父类变出子类的过程，定义一个类的同时，声明它的父类，就完成了继承

对了 不要关心为什么上面那个扫地的在擦黑板，而擦黑板的坐着休息 他与她在谈恋爱

#### 注意啦 现在开始用英文写脚本了 ####

定义类，使用`class`，这个英文单词本身就是类的意思

声明父类，使用左尖括号`<`，有点像个箭头，由父类指向子类，表示派生

定义方法，使用`def`，英文全名是define，定义的意思，但只用来定义方法

结束定义统一是`end`，英文结束的意思

把上面的俩苦逼同学再写一遍

```
# 清洁工
class Cleaner # 这个Cleaner是名字 必须是大写字母开头想必不用我说
  def work # 方法名 可以是小写字母、汉字或下划线开头
    puts "我不知道我要干什么"
  end
  # puts是什么？
  #  向控制台写文字的方法 它会把它的参数写下来
  # 为什么这里的[我不知道我要干什么]加了双引号？
  #  你要让电脑明白：这是一句话，不是用来执行的脚本
  def rest
    puts "我在休息"
  end
end
#------
# 擦黑板的
class Wiper < Cleaner # 这就是上面那个Cleaner
  def work
    洗拖把
    拖来拖去 # 这些方法我就不再一一实现了
  end
end
#------
# 扫地的
class Sweeper < Cleaner
  def work
    洗抹布
    擦来擦去
  end
end
```

这里出现了三个同名的方法：`work` `work` 和 `work`，其实这里暗藏玄机哦~

第一个`work` 作为第一次出现的方法，没什么特殊的

第二个`work` 它出现在`Wiper`内部，而`Wiper`是`Cleaner`的子类

很显然，父类有的方法，子类一定有，不然我要**继承**干什么？在这里，你可以看做是`Wiper`的内部出现了第二次`work`的定义

这个定义会覆盖掉之前的定义，这样`Wiper`有了它独有的`work`

第三个`work` 在`Sweeper`内，也是`Cleaner`的子类，同理覆盖了从第一个`work`里继承来的内容

所以，三个类，有了三个不同的`work`

…………

……………………

………………………………

好吧，不要打我，就是这么简单，可能我说的有点绕……

你们可以想到，`rest`虽然只出现了一次，但是三个类中都是有这个东西的
#### 简单的讲一讲模块 ####
在上面，我们看到，*李华*是*红星中学高二一班的好学生*，而*红星中学高二一班的好学生*都是*懂物理知识的人*，我们要*做物理实验*需要*懂物理知识的人*所以李华可以胜任。

（某对象o属于某类A，某类A的父类是某类B，某类B具有某实例方法m，所以对象o具有方法m）

但是，如果我们现在要*调查北京市2006-2011年全市狗尾巴草种群数量变化*，需要*懂生物知识的人*，李华也懂生物，所以我们让他的某个祖先类为*懂生物知识的人*………………

好像哪里不对劲？

我们刚才已经说过，某个类只能有一个父类，这个父类当然也是一个类，它也只能有一个父类……层层下去，关系应该是这样的（`<`的左边是子类 右边是父类）

子类 < 父类 < 父类的父类 < 父类他爷爷 < ...... < 祖先类 < ...... (< Object)

后面那个Object不需要理解，但是你们应该猜得到，它是一个类，是所有类的父类或祖先类

现在，我们看到，李华的类的父类是*懂物理知识的人*，而现在他的某一个祖先类是*懂生物知识的人*…………

难道说，所有*懂物理知识的人*都是*懂生物知识的人*？或者所有*懂生物知识的人*都是*懂物理知识的人*？

坑爹呢你是

因为我们没有办法把这两个类并排（某个类只能有一个老爸，别管干爹了…………都说了不要问他妈是谁！），而且李华肯定不止拥有这两种能力，比如说，李华还是个*学生*

这时，我们应该选择最能代表事物根本属性的类作为父类，将另外的作为**模块**（终于讲到你了）

在模块中，我们可以像在类中一样定义方法，但是**模块不能创建对象**

在这里，我们的*李华*属于类*A红星中学高二一班的学生*（问什么在前面加个A？我说过的，类名必须以大写字母开头），这个类应该是这样的继承下来：

红星中学高二一班的学生 < 红星中学高二年级的学生 < 红星中学的学生 < 高中生 < 学生 < 青少年 < 超人

与此同时，应该在其中的某个类中**混入**模块

当我们向某个类A中混入模块M，在M中定义的所有方法，A也能拥有

模块的混入没有限制，想要几个就要几个

这里，我们要把*懂物理知识的人*作为模块，*懂生物知识的人*做为另一个模块，把它们混入*红星中学高二一班的学生*中，因为红星中学高二一班的学生都懂这些东西，而红星中学高二年级的学生不一定都懂，好班级就是不一样(打死)

而且这样还有个好处：当某个老师需要这种能力的时候，我们只需要混入这两个模块，而不需要更改学生或老师的继承结构

声明模块 使用`module`
```
module M懂物理知识的人 # 模块的名字也必须以大写字母开头
  def 做物理实验(数据)
    # 出现了新的关键词 case
    case 数据
    when "复述质能方程"
      puts "E = mc<sup>2</sup>"
      # 还记得puts吗？
    else
      puts "我不会"
    end
  end
end
#-----
module M懂生物知识的人
  def 做生物调查(数据)
    puts "我不会#{数据}" # 这里的写法你们将会很熟悉
  end
end
#-----
class A红星中学高二一班的学生 < A红星中学高二年级的学生 # 后面这个父类我就不再定义了
  include M懂物理知识的人
  include M懂生物知识的人
  # 这样就混入了
  # 下面的方法有两个参数
  def 做(什么, 具体数据)
    case 什么
    when "物理实验"
      做物理实验(具体数据)
    when "生物调查"
      做生物调查(具体数据)
    else
      puts "我不会"
    end
  end
end
李华 = A红星中学高二一班的学生.new
李华.做("物理实验", "复述质能方程")
#=> E = mc<sup>2</sup>
```

什么？做物理实验和复述质能方程有什么关系？你不知道现在的高中生做的实验都是黑板实验吗？

# 厌倦了这些理论吗？我们直接来实践吧~ #